<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一篇就够了：HTTP基础知识一网打尽 | 潜心摸鱼，戒骄戒躁</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="....">
    <link rel="preload" href="/assets/css/0.styles.8ada974c.css" as="style"><link rel="preload" href="/assets/js/app.be40bd60.js" as="script"><link rel="preload" href="/assets/js/2.fcfb7384.js" as="script"><link rel="preload" href="/assets/js/9.89661334.js" as="script"><link rel="prefetch" href="/assets/js/10.a9ac570e.js"><link rel="prefetch" href="/assets/js/11.416a0fa6.js"><link rel="prefetch" href="/assets/js/12.0b6b2e75.js"><link rel="prefetch" href="/assets/js/3.c76c3f2c.js"><link rel="prefetch" href="/assets/js/4.b6579f35.js"><link rel="prefetch" href="/assets/js/5.b086611e.js"><link rel="prefetch" href="/assets/js/6.9ea11631.js"><link rel="prefetch" href="/assets/js/7.296733e2.js"><link rel="prefetch" href="/assets/js/8.d1df2860.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ada974c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">潜心摸鱼，戒骄戒躁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端知识体系" class="dropdown-title"><span class="title">前端知识体系</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/articles/react.html" class="nav-link">
  一篇就够了：React全家桶
</a></li><li class="dropdown-item"><!----> <a href="/articles/network.html" class="nav-link router-link-exact-active router-link-active">
  一篇就够了：Http基础知识一网打尽
</a></li><li class="dropdown-item"><!----> <a href="/articles/optimize.html" class="nav-link">
  一篇就够了：前端性能优化
</a></li><li class="dropdown-item"><!----> <a href="/articles/css.html" class="nav-link">
  必知必会：CSS
</a></li><li class="dropdown-item"><!----> <a href="/articles/es6.html" class="nav-link">
  必知必会：JavaScript与ES6
</a></li><li class="dropdown-item"><!----> <a href="/articles/node.html" class="nav-link">
  必知必会：Node.js
</a></li><li class="dropdown-item"><!----> <a href="/articles/design-patterns.html" class="nav-link">
  必知必会：设计模式
</a></li><li class="dropdown-item"><!----> <a href="/articles/security.html" class="nav-link">
  必知必会：Web安全
</a></li><li class="dropdown-item"><!----> <a href="/articles/algorithm.html" class="nav-link">
  必知必会：算法
</a></li><li class="dropdown-item"><!----> <a href="/articles/engineer.html" class="nav-link">
  必知必会：工程化与部署
</a></li><li class="dropdown-item"><!----> <a href="/articles/multi-terminal.html" class="nav-link">
  快速上手：多端（Taro）
</a></li><li class="dropdown-item"><!----> <a href="/articles/webpack-v5.html" class="nav-link">
  快速上手：Webpack 5.0
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="手写题" class="dropdown-title"><span class="title">手写题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/articles/debounce-throttle.html" class="nav-link">
  防抖、节流
</a></li><li class="dropdown-item"><!----> <a href="/articles/copy.html" class="nav-link">
  深浅拷贝
</a></li><li class="dropdown-item"><!----> <a href="/articles/entrust.html" class="nav-link">
  事件委托
</a></li><li class="dropdown-item"><!----> <a href="/articles/new.html" class="nav-link">
  new
</a></li><li class="dropdown-item"><!----> <a href="/articles/promise.html" class="nav-link">
  promise
</a></li><li class="dropdown-item"><!----> <a href="/articles/call-apply-bind.html" class="nav-link">
  call、apply、bind
</a></li><li class="dropdown-item"><!----> <a href="/articles/curry.html" class="nav-link">
  函数柯里化
</a></li><li class="dropdown-item"><!----> <a href="/articles/drag-dom.html" class="nav-link">
  实现拖拽div
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="有趣的小项目" class="dropdown-title"><span class="title">有趣的小项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/articles/little-news.html" class="nav-link">
  Chrome插件：前端小报
</a></li><li class="dropdown-item"><!----> <a href="/articles/green-wall.html" class="nav-link">
  VSCode插件：用Github小绿点画个画
</a></li><li class="dropdown-item"><!----> <a href="/articles/ftp-deploy.html" class="nav-link">
  Webpack Plugin：ftpDeploy
</a></li><li class="dropdown-item"><!----> <a href="/articles/multi-language.html" class="nav-link">
  Webpack Loader：多语言
</a></li><li class="dropdown-item"><!----> <a href="/articles/apm.html" class="nav-link">
  前端性能监控系统搭建
</a></li><li class="dropdown-item"><!----> <a href="/articles/code-rule.html" class="nav-link">
  团队开发：代码规范
</a></li><li class="dropdown-item"><!----> <a href="/articles/cli.html" class="nav-link">
  团队开发：React项目脚手架
</a></li><li class="dropdown-item"><!----> <a href="/articles/component.html" class="nav-link">
  团队开发：React项目组件库
</a></li><li class="dropdown-item"><!----> <a href="/articles/component.html" class="nav-link">
  团队开发：项目模板
</a></li></ul></div></div> <a href="https://github.com/Xumengxiang/inner-peace" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端知识体系" class="dropdown-title"><span class="title">前端知识体系</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/articles/react.html" class="nav-link">
  一篇就够了：React全家桶
</a></li><li class="dropdown-item"><!----> <a href="/articles/network.html" class="nav-link router-link-exact-active router-link-active">
  一篇就够了：Http基础知识一网打尽
</a></li><li class="dropdown-item"><!----> <a href="/articles/optimize.html" class="nav-link">
  一篇就够了：前端性能优化
</a></li><li class="dropdown-item"><!----> <a href="/articles/css.html" class="nav-link">
  必知必会：CSS
</a></li><li class="dropdown-item"><!----> <a href="/articles/es6.html" class="nav-link">
  必知必会：JavaScript与ES6
</a></li><li class="dropdown-item"><!----> <a href="/articles/node.html" class="nav-link">
  必知必会：Node.js
</a></li><li class="dropdown-item"><!----> <a href="/articles/design-patterns.html" class="nav-link">
  必知必会：设计模式
</a></li><li class="dropdown-item"><!----> <a href="/articles/security.html" class="nav-link">
  必知必会：Web安全
</a></li><li class="dropdown-item"><!----> <a href="/articles/algorithm.html" class="nav-link">
  必知必会：算法
</a></li><li class="dropdown-item"><!----> <a href="/articles/engineer.html" class="nav-link">
  必知必会：工程化与部署
</a></li><li class="dropdown-item"><!----> <a href="/articles/multi-terminal.html" class="nav-link">
  快速上手：多端（Taro）
</a></li><li class="dropdown-item"><!----> <a href="/articles/webpack-v5.html" class="nav-link">
  快速上手：Webpack 5.0
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="手写题" class="dropdown-title"><span class="title">手写题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/articles/debounce-throttle.html" class="nav-link">
  防抖、节流
</a></li><li class="dropdown-item"><!----> <a href="/articles/copy.html" class="nav-link">
  深浅拷贝
</a></li><li class="dropdown-item"><!----> <a href="/articles/entrust.html" class="nav-link">
  事件委托
</a></li><li class="dropdown-item"><!----> <a href="/articles/new.html" class="nav-link">
  new
</a></li><li class="dropdown-item"><!----> <a href="/articles/promise.html" class="nav-link">
  promise
</a></li><li class="dropdown-item"><!----> <a href="/articles/call-apply-bind.html" class="nav-link">
  call、apply、bind
</a></li><li class="dropdown-item"><!----> <a href="/articles/curry.html" class="nav-link">
  函数柯里化
</a></li><li class="dropdown-item"><!----> <a href="/articles/drag-dom.html" class="nav-link">
  实现拖拽div
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="有趣的小项目" class="dropdown-title"><span class="title">有趣的小项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/articles/little-news.html" class="nav-link">
  Chrome插件：前端小报
</a></li><li class="dropdown-item"><!----> <a href="/articles/green-wall.html" class="nav-link">
  VSCode插件：用Github小绿点画个画
</a></li><li class="dropdown-item"><!----> <a href="/articles/ftp-deploy.html" class="nav-link">
  Webpack Plugin：ftpDeploy
</a></li><li class="dropdown-item"><!----> <a href="/articles/multi-language.html" class="nav-link">
  Webpack Loader：多语言
</a></li><li class="dropdown-item"><!----> <a href="/articles/apm.html" class="nav-link">
  前端性能监控系统搭建
</a></li><li class="dropdown-item"><!----> <a href="/articles/code-rule.html" class="nav-link">
  团队开发：代码规范
</a></li><li class="dropdown-item"><!----> <a href="/articles/cli.html" class="nav-link">
  团队开发：React项目脚手架
</a></li><li class="dropdown-item"><!----> <a href="/articles/component.html" class="nav-link">
  团队开发：React项目组件库
</a></li><li class="dropdown-item"><!----> <a href="/articles/component.html" class="nav-link">
  团队开发：项目模板
</a></li></ul></div></div> <a href="https://github.com/Xumengxiang/inner-peace" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/articles/network.html" class="active sidebar-link">一篇就够了：HTTP 基础知识一网打尽</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/network.html#http协议" class="sidebar-link">HTTP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/network.html#与http相关的协议" class="sidebar-link">与HTTP相关的协议</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#http的特点" class="sidebar-link">HTTP的特点</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#http的缺点" class="sidebar-link">HTTP的缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/articles/network.html#http-版本" class="sidebar-link">HTTP 版本</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/network.html#http-0-9" class="sidebar-link">HTTP 0.9</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#http-1-0" class="sidebar-link">HTTP 1.0</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#http-1-1" class="sidebar-link">HTTP 1.1</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#http-2-0" class="sidebar-link">HTTP 2.0</a></li></ul></li><li class="sidebar-sub-header"><a href="/articles/network.html#请求方法" class="sidebar-link">请求方法</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#常见错误码" class="sidebar-link">常见错误码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/network.html#_1xx-信息类" class="sidebar-link">1xx 信息类</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#_2xx-成功" class="sidebar-link">2xx 成功</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#_3xx-重定向" class="sidebar-link">3xx 重定向</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#_4xx-客户端错误" class="sidebar-link">4xx 客户端错误</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#_5xx-服务器错误" class="sidebar-link">5xx 服务器错误</a></li></ul></li><li class="sidebar-sub-header"><a href="/articles/network.html#缓存机制" class="sidebar-link">缓存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/network.html#缓存的规则" class="sidebar-link">缓存的规则</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#缓存的方案" class="sidebar-link">缓存的方案</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#缓存的优点" class="sidebar-link">缓存的优点</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#不同刷新的请求执行过程" class="sidebar-link">不同刷新的请求执行过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/articles/network.html#https" class="sidebar-link">HTTPS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/network.html#https和http的区别" class="sidebar-link">HTTPS和HTTP的区别</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#为什么使用https" class="sidebar-link">为什么使用HTTPS</a></li><li class="sidebar-sub-header"><a href="/articles/network.html#https的原理" class="sidebar-link">HTTPS的原理</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一篇就够了：http基础知识一网打尽"><a href="#一篇就够了：http基础知识一网打尽" class="header-anchor">#</a> 一篇就够了：<code>HTTP</code>基础知识一网打尽</h1> <p><img src="/network.jpg" alt="一篇就够了：HTTP 基础知识一网打尽"></p> <h2 id="http协议"><a href="#http协议" class="header-anchor">#</a> <code>HTTP</code>协议</h2> <p><code>HTTP</code> 协议是一种无状态的、处于应用层的、以请求/应答方式运行的协议，使用可扩展的语义和自描述的信息格式，与基于网络的超文本信息系统灵活的相互作用。</p> <h3 id="与http相关的协议"><a href="#与http相关的协议" class="header-anchor">#</a> 与<code>HTTP</code>相关的协议</h3> <h4 id="osi模型"><a href="#osi模型" class="header-anchor">#</a> <code>OSI</code>模型</h4> <p><code>OSI</code>（Open System Interconnection Reference Model），开放式系统互联通信参考模型，也就是我们常说的 7 层模型。从它的名称就可以看出来，<code>OSI</code> 只是一个供参考的概念模型，它从未被真正的实现。<code>OSI</code> 的 7 层，从上至下分别是：</p> <p><img src="/osi.jpg" alt="OSI模型"></p> <table><thead><tr><th style="text-align:left;"><code>OSI</code>分层</th> <th style="text-align:left;">作用</th></tr></thead> <tbody><tr><td style="text-align:left;">L7 应用层</td> <td style="text-align:left;">解决业务问题，面向具体的应用传输数据</td></tr> <tr><td style="text-align:left;">L6 表示层</td> <td style="text-align:left;">将消息转换为应用层可以读取的消息</td></tr> <tr><td style="text-align:left;">L5 会话层</td> <td style="text-align:left;">建立会话、握手、维持网络的连接状态</td></tr> <tr><td style="text-align:left;">L4 传输层</td> <td style="text-align:left;">包括我们熟悉的 <code>TCP</code> 与 <code>UDP</code> 等，解决进程与进程之间的通讯</td></tr> <tr><td style="text-align:left;">L3 网络层</td> <td style="text-align:left;">主要包括 <code>IP</code> 协议，负责将报文从因特网上的一个主机发送到另一个主机上</td></tr> <tr><td style="text-align:left;">L2 数据链路层</td> <td style="text-align:left;">工作在局域网中，使用 <code>MAC</code> 地址标记网络上的设备，如路由器，然后将报文转到主机上</td></tr> <tr><td style="text-align:left;">L1 物理层</td> <td style="text-align:left;">电缆、光纤等</td></tr></tbody></table> <h4 id="tcp-ip模型"><a href="#tcp-ip模型" class="header-anchor">#</a> <code>TCP/IP</code>模型</h4> <p><code>OSI</code> 只是一个概念模型，而平常工作我们最常用的还是 <code>TCP/IP</code> 模型。<code>TCP/IP</code> 模型其实就是 <code>OSI</code> 模型的简化版本，也就是我们平时所说的 4 层模型。<code>TCP/IP</code> 的 4 层，由上至下分别是：</p> <p><img src="/tcpip.jpg" alt="TCP/IP模型"></p> <p>通过上图我们可以看出，其实 <code>TCP/IP</code> 模型与 <code>OSI</code> 模型十分相似，主要是省略了表示层、会话层与物理层的实现。这里每一层的功能实际上与对应的 <code>OSI</code> 模型十分类似，所以就不再罗列了。下面是一张 <code>OSI</code> 模型与 <code>TCP/IP</code> 模型的层级对照图，大家可以通过对照图来总结 <code>TCP/IP</code> 模型中各层的职责。</p> <p><img src="/osi-tcpip.jpg" alt="OSI-TCP/IP模型"></p> <p>网络分层的好处是，每一次层都只负责自己的任务，其他层的事情完全不需要考虑，层次之间交互的时候，只需要调用接口就可以了。当某一层需要修改的时候，也完全不影响其他的功能。当然，有优势就一定有劣势，每一次进行网络通信的时候，都需要由上至下，一层一层的传递信息，反过来，又要一层一层的向上传递，对于性能的影响是比较大的。</p> <h4 id="tcp三次握手、四次挥手"><a href="#tcp三次握手、四次挥手" class="header-anchor">#</a> <code>TCP</code>三次握手、四次挥手</h4> <h5 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h5> <p>所谓三次握手(Three-way Handshake)，是指建立一个 <code>TCP</code> 连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立 <code>TCP</code> 连接，并同步连接双方的序列号和确认号，交换 <code>TCP</code> 窗口大小信息。在 <code>socket</code> 编程中，客户端执行 <code>connect()</code> 时，将触发三次握手。</p> <p><img src="/handshake.jpg" alt="三次握手"></p> <ul><li><strong>第一次握手(<code>SYN=1, seq=x</code>)</strong>：客户端发送一个 <code>TCP</code> 的 <code>SYN</code> 标志位置<code>1</code>的包，指明客户端打算连接的服务器的端口，以及初始序号 <code>X</code>，保存在包头的序列号(Sequence Number)字段里。发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li> <li><strong>第二次握手(<code>SYN=1, ACK=1, seq=y, ACKnum=x+1</code>)</strong>：服务器发回确认包(<code>ACK</code>)应答。即 <code>SYN</code> 标志位和 <code>ACK</code> 标志位均为1。服务器端选择自己 <code>ISN</code> 序列号，放到 <code>Seq</code> 域里，同时将确认序号(Acknowledgement Number)设置为客户的 <code>ISN</code> 加1，即<code>X+1</code>。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li> <li><strong>第三次握手(<code>ACK=1，ACKnum=y+1</code>)</strong>：客户端再次发送确认包(<code>ACK</code>)<code>，SYN</code> 标志位为0，<code>ACK</code> 标志位为1，并且把服务器发来 <code>ACK</code> 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写<code>ISN</code>的+1。发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，<code>TCP</code> 握手结束。</li></ul> <h5 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h5> <p><code>TCP</code> 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 <code>socket</code> 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p> <p><img src="/handwave.jpg" alt="四次挥手"></p> <ul><li><strong>第一次挥手(<code>FIN=1，seq=x</code>)</strong>：假设客户端想要关闭连接，客户端发送一个 <code>FIN</code> 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</li> <li><strong>第二次挥手(<code>ACK=1，ACKnum=x+1</code>)</strong>：服务器端确认客户端的 <code>FIN</code> 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</li> <li><strong>第三次挥手(<code>FIN=1，seq=y</code>)</strong>：服务器端准备好关闭连接时，向客户端发送结束连接请求，<code>FIN</code> 置为1。发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个<code>ACK</code>。</li> <li><strong>第四次挥手(<code>ACK=1，ACKnum=y+1</code>)</strong>：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入<code>TIME_WAIT</code>状态，等待可能出现的要求重传的 <code>ACK</code> 包。服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。客户端等待了某个固定时间（两个最大段生命周期，<code>2MSL</code>，2 Maximum Segment Lifetime）之后，没有收到服务器端的 <code>ACK</code> ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</li></ul> <h4 id="url的组成"><a href="#url的组成" class="header-anchor">#</a> <code>URL</code>的组成</h4> <p><code>URL</code>，统一资源定位符的简称，Uniform Resource Locator，常常被称为网址，是因特网上标准的资源地址。</p> <p><strong>通用的格式</strong>：<code>scheme</code>: // <code>host</code>[: <code>port</code>]/<code>path</code>/…/?<code>query</code>#<code>anchor</code></p> <table><thead><tr><th style="text-align:left;">名称</th> <th style="text-align:left;">功能</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>scheme</code></td> <td style="text-align:left;">访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等</td></tr> <tr><td style="text-align:left;"><code>host</code></td> <td style="text-align:left;">HTTP 服务器的 IP 地址或者域名</td></tr> <tr><td style="text-align:left;"><code>port</code></td> <td style="text-align:left;">HTTP 服务器的默认端口是 80，HTTPS默认端口是443，这种情况下端口号可以省略，如果使用了别的端口，必须指明。不同的端口，你可以认为是不同的应用程序。</td></tr> <tr><td style="text-align:left;"><code>path</code></td> <td style="text-align:left;">访问资源的路径</td></tr> <tr><td style="text-align:left;"><code>query-string</code></td> <td style="text-align:left;">发给 http 服务器的数据</td></tr> <tr><td style="text-align:left;"><code>anchor</code></td> <td style="text-align:left;">锚点</td></tr></tbody></table> <h4 id="dns工作原理"><a href="#dns工作原理" class="header-anchor">#</a> <code>DNS</code>工作原理</h4> <p><code>DNS</code> 协议提供的是一种主机名到 <code>IP</code> 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在<code>UDP</code>协议之上，使用的是53端口号。</p> <p><img src="/dns.png" alt="dns"></p> <p>这张图很生动的展示了<code>DNS</code>在本地<code>DNS</code>服务器是如何查询的，一般向本地<code>DNS</code>服务器发送请求是递归查询的。</p> <p>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程👇</p> <p><img src="/dnssearch.png" alt="dnssearch"></p> <h3 id="http的特点"><a href="#http的特点" class="header-anchor">#</a> <code>HTTP</code>的特点</h3> <p><code>HTTP</code>是一个属于应用层的面向对象的协议，<code>HTTP</code>协议一共有五大特点：</p> <ul><li><strong>支持客户/服务器模式</strong></li> <li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有<code>GET</code>、<code>HEAD</code>、<code>POST</code>。每种方法规定了客户与服务器联系的类型不同。由于<code>HTTP</code>协议简单，使得<code>HTTP</code>服务器的程序规模小，因而通信速度很快。</li> <li><strong>灵活</strong>：<code>HTTP</code>允许传输任意类型的数据对象。正在传输的类型由<code>Content-Type</code>（<code>Content-Type</code>是<code>HTTP</code>包中用来表示内容类型的标识）加以标记。</li> <li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li> <li><strong>无状态</strong>：<code>HTTP</code>协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul> <h3 id="http的缺点"><a href="#http的缺点" class="header-anchor">#</a> <code>HTTP</code>的缺点</h3> <ul><li><strong>无状态</strong>：无状态在部分场景下是缺点，比如：购物系统，无法保留顾客信息。</li> <li><strong>明文传输</strong>：协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让<code>HTTP</code>的报文信息暴露给了外界，给攻击者带来了便利。</li> <li><strong>队头阻塞</strong>：当同时发起多个<code>HTTP</code>请求时，共用一个<code>TCP</code>连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。</li></ul> <h2 id="http-版本"><a href="#http-版本" class="header-anchor">#</a> <code>HTTP</code> 版本</h2> <h3 id="http-0-9"><a href="#http-0-9" class="header-anchor">#</a> <code>HTTP 0.9</code></h3> <ul><li>1991年,原型版本，功能简陋，只有一个命令<code>GET</code>，只支持纯文本内容，该版本已过时。</li></ul> <h3 id="http-1-0"><a href="#http-1-0" class="header-anchor">#</a> <code>HTTP 1.0</code></h3> <ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</li> <li>除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令。</li> <li><code>http</code>请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（<code>HTTP header</code>），用来描述一些元数据。</li> <li>只使用 <code>header</code> 中的 <code>If-Modified-Since</code> 和 <code>Expires</code> 作为缓存失效的标准。</li> <li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li> <li>通常每台计算机只能绑定一个 <code>IP</code>，所以请求消息中的 <code>URL</code> 并没有传递主机名（<code>hostname</code>）</li></ul> <h3 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> <code>HTTP 1.1</code></h3> <p><code>http1.1</code>是目前最为主流的<code>http</code>协议版本，从1999年发布至今，仍是主流的<code>http</code>协议版本。</p> <ul><li><strong>持久连接</strong>：即<code>TCP</code>连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置。</li> <li><strong>管道机制</strong>：即在同一个<code>TCP</code>连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。</li> <li><code>HTTP 1.1</code> 中新增加了 <code>E-tag</code>，<code>If-Unmodified-Since</code>, <code>If-Match</code>, <code>If-None-Match</code> 等缓存控制标头来控制缓存失效。</li> <li><strong>断点续传</strong>：通过使用请求头中的 <code>Range</code> 来实现。</li> <li><strong>虚拟网络</strong>：在一台物理服务器上可以存在多个虚拟主机（<code>Multi-homed Web Servers</code>），并且它们共享一个<code>IP</code>地址。</li> <li>新增方法：<code>PUT</code>、 <code>PATCH</code>、 <code>OPTIONS</code>、 <code>DELETE</code>。</li></ul> <h3 id="http-2-0"><a href="#http-2-0" class="header-anchor">#</a> <code>HTTP 2.0</code></h3> <ul><li><strong>二进制分帧</strong>：这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;：头信息帧和数据帧。</li> <li><strong>头部压缩</strong>：<code>HTTP 1.1</code>版本会出现 <code>User-Agent</code>、<code>Cookie</code>、<code>Accept</code>、<code>Server</code>、<code>Range</code> 等字段可能会占用几百甚至几千字节，而 <code>Body</code> 却经常只有几十字节，所以导致头部偏重。<code>HTTP 2.0</code> 使用 <code>HPACK</code> 算法进行压缩。</li> <li><strong>多路复用</strong>：复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</li> <li><strong>服务器推送</strong>：允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li> <li><strong>请求优先级</strong>：可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul> <h2 id="请求方法"><a href="#请求方法" class="header-anchor">#</a> 请求方法</h2> <p><code>HTTP1.0</code>定义了三种请求方法： <code>GET</code>、 <code>POST</code> 和 <code>HEAD</code>方法。</p> <p><code>HTTP1.1</code>新增了五种请求方法：<code>OPTIONS</code>、<code>PUT</code>、 <code>DELETE</code>、 <code>TRACE</code> 和 <code>CONNECT</code>。</p> <table><thead><tr><th style="text-align:left;">方法</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>GET</code></td> <td style="text-align:left;">通常用于请求服务器发送某些资源</td></tr> <tr><td style="text-align:left;"><code>HEAD</code></td> <td style="text-align:left;">请求资源的头部信息, 并且这些头部与 <code>HTTP</code> <code>GET</code> 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源</td></tr> <tr><td style="text-align:left;"><code>OPTIONS</code></td> <td style="text-align:left;">用于获取目的资源所支持的通信选项</td></tr> <tr><td style="text-align:left;"><code>POST</code></td> <td style="text-align:left;">发送数据给服务器</td></tr> <tr><td style="text-align:left;"><code>PUT</code></td> <td style="text-align:left;">用于新增资源或者使用请求中的有效负载替换目标资源的表现形式</td></tr> <tr><td style="text-align:left;"><code>DELETE</code></td> <td style="text-align:left;">用于删除指定的资源</td></tr> <tr><td style="text-align:left;"><code>PATCH</code></td> <td style="text-align:left;">用于对资源进行部分修改</td></tr> <tr><td style="text-align:left;"><code>CONNECT</code></td> <td style="text-align:left;"><code>HTTP/1.1</code>协议中预留给能够将连接改为管道方式的代理服务器</td></tr> <tr><td style="text-align:left;"><code>TRACE</code></td> <td style="text-align:left;">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table> <h2 id="常见错误码"><a href="#常见错误码" class="header-anchor">#</a> 常见错误码</h2> <p>RFC 规定 HTTP 的状态码为「三位数」，第一个数字定义了响应的类别，被分为五类:</p> <h3 id="_1xx-信息类"><a href="#_1xx-信息类" class="header-anchor">#</a> 1xx 信息类</h3> <ul><li>接受的请求正在处理，信息类状态码。</li></ul> <h3 id="_2xx-成功"><a href="#_2xx-成功" class="header-anchor">#</a> 2xx 成功</h3> <ul><li>200 OK 表示从客户端发来的请求在服务器端被正确请求。</li> <li>204 No content，表示请求成功，但没有资源可返回。</li> <li>206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 「Content-Range」 指定范围的实体内容。</li></ul> <h3 id="_3xx-重定向"><a href="#_3xx-重定向" class="header-anchor">#</a> 3xx 重定向</h3> <ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。</li> <li>302 found，临时性重定向，表示资源临时被分配了新的 URL。</li> <li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源。</li> <li>304 not modified，当协商缓存命中时会返回这个状态码。</li> <li>307 temporary redirect，临时重定向，和302含义相同,不会改变method</li></ul> <blockquote><p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p></blockquote> <h3 id="_4xx-客户端错误"><a href="#_4xx-客户端错误" class="header-anchor">#</a> 4xx 客户端错误</h3> <ul><li>400 bad request，请求报文存在语法错误。</li> <li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。</li> <li>403 forbidden，表示对请求资源的访问被服务器拒绝。</li> <li>404 not found，表示在服务器上没有找到请求的资源。</li> <li>405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 👇</li></ul> <div class="language-txt extra-class"><pre class="language-text"><code>Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE
</code></pre></div><h3 id="_5xx-服务器错误"><a href="#_5xx-服务器错误" class="header-anchor">#</a> 5xx 服务器错误</h3> <ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li> <li>502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li> <li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul> <h2 id="缓存机制"><a href="#缓存机制" class="header-anchor">#</a> 缓存机制</h2> <p>缓存机制无处不在，有客户端缓存，服务端缓存，代理服务器缓存等。在<code>HTTP</code>中具有缓存功能的是浏览器缓存。 <code>HTTP</code>缓存作为<code>web</code>性能优化的重要手段，对于从事<code>web</code>开发的朋友有重要的意义。</p> <h3 id="缓存的规则"><a href="#缓存的规则" class="header-anchor">#</a> 缓存的规则</h3> <p>我们知道<code>HTTP</code>的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。</p> <h4 id="强制缓存"><a href="#强制缓存" class="header-anchor">#</a> 强制缓存</h4> <p>当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。</p> <p><img src="/qzhc.jpg" alt="强制缓存"></p> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p>又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。</p> <p><img src="/xshc.jpg" alt="协商缓存"></p> <blockquote><p>两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。</p></blockquote> <h3 id="缓存的方案"><a href="#缓存的方案" class="header-anchor">#</a> 缓存的方案</h3> <p>上面的内容让我们大概了解了缓存机制是怎样运行的，但是，服务器是如何判断缓存是否失效呢？我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为<code>HTTP</code>报文。报文中包含首部<code>header</code>和主体部分<code>body</code>。与缓存相关的规则信息就包含在<code>header</code>中。<code>boby</code>中的内容是<code>HTTP</code>请求真正要传输的部分。举个<code>HTTP</code>报文<code>header</code>部分的例子如下：</p> <div class="language-http extra-class"><pre class="language-http"><code>Response Header
  Cache-Control: max-age=30000000
  Connection: keep-alive
  Content-Encoding: gzip
  Content-Type: application-javascript
  Date: Tue, 24 Jan 2020 10:30:30 GMT
  ETag: W/&quot;'58846adf-110dfe'&quot;
  Last-Modified: Tue, 24 Jan 2020 10:30:30 GMT

</code></pre></div><p>接下来我们将对<code>HTTP</code>报文中出现的与缓存规则相关的信息做出详细解释。（我们依旧分为强制缓存和协商缓存两个方面来介绍）。</p> <h4 id="强制缓存-2"><a href="#强制缓存-2" class="header-anchor">#</a> 强制缓存</h4> <p>对于强制缓存，服务器响应的<code>header</code>中会用两个字段来表明 —— <code>Expires</code>和<code>Cache-Control</code>。</p> <h5 id="expires"><a href="#expires" class="header-anchor">#</a> <code>Expires</code></h5> <p><code>Exprires</code>的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，<code>Expires</code>是<code>HTTP1.0</code>的产物，故现在大多数使用<code>Cache-Control</code>替代。</p> <h5 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> <code>Cache-Control</code></h5> <p><code>Cache-Control</code>有很多属性，不同的属性代表的意义也不同。</p> <ul><li><strong>private</strong>：客户端可以缓存</li> <li><strong>public</strong>：客户端和代理服务器都可以缓存</li> <li><strong>max-age=t</strong>：缓存内容将在t秒后失效</li> <li><strong>no-cache</strong>：需要使用协商缓存来验证缓存数据</li> <li><strong>no-store</strong>：所有内容都不会缓存。</li></ul> <h4 id="协商缓存-2"><a href="#协商缓存-2" class="header-anchor">#</a> 协商缓存</h4> <p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。
对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p> <h5 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="header-anchor">#</a> <code>Last-Modified</code>/<code>If-Modified-Since</code></h5> <p><code>**Last-Modified**</code>： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p> <p><code>**if-Modified-Since**</code>:
浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有<code>if-Modified-Since</code>，则与被请求资源的最后修改时间进行对比，如果一致则返回<code>304</code>和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说：从某个时间节点算起，是否文件被修改了。</p> <ul><li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li> <li>如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</li></ul> <h5 id="etag-if-none-match"><a href="#etag-if-none-match" class="header-anchor">#</a> <code>ETag</code>/<code>If-None-Match</code></h5> <p><code>**ETag**</code>：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。
<code>**If-None-Match**</code>：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现<code>If-None-Match</code>则与被请求资源的唯一标识进行对比。</p> <ul><li>不同，说明资源被改动过，则响应整个资源内容，返回状态码200。</li> <li>相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304。</li></ul> <blockquote><p>但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。</p></blockquote> <h3 id="缓存的优点"><a href="#缓存的优点" class="header-anchor">#</a> 缓存的优点</h3> <ul><li>减少了冗余的数据传递，节省宽带流量</li> <li>减少了服务器的负担，大大提高了网站性能</li> <li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因</li></ul> <h3 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="header-anchor">#</a> 不同刷新的请求执行过程</h3> <ul><li><strong>浏览器输入URL</strong>：浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）。</li> <li><strong><code>F5</code>刷新</strong>：<code>F5</code>就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上<code>If-Modify-since</code>。</li> <li><strong><code>Ctrl+F5</code></strong>：告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作。</li></ul> <h2 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h2> <p><code>HTTPS</code>（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的<code>HTTP</code>通道，简单讲是<code>HTTP</code>的安全版。即<code>HTTP</code>下加入<code>SSL</code>层，<code>HTTPS</code>的安全基础是<code>SSL</code>，因此加密的详细内容就需要<code>SSL</code>。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p> <h3 id="https和http的区别"><a href="#https和http的区别" class="header-anchor">#</a> <code>HTTPS</code>和<code>HTTP</code>的区别</h3> <ul><li><code>HTTP</code> 是明文传输，<code>HTTPS</code> 通过 <code>SSL\TLS</code> 进行了加密。</li> <li><code>HTTP</code> 的端口号是 <code>80</code>，HTTPS 是 <code>443</code>。</li> <li><code>HTTPS</code> 需要到 <code>CA</code> 申请证书，一般免费证书很少，需要交费。</li> <li><code>HTTP</code> 的连接很简单，是无状态的；<code>HTTPS</code> 协议是由 <code>SSL</code>+<code>HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议，比 <code>HTTP</code> 协议安全。</li></ul> <h3 id="为什么使用https"><a href="#为什么使用https" class="header-anchor">#</a> 为什么使用<code>HTTPS</code></h3> <p><code>HTTPS</code> 最主要的用处是以下两点：</p> <ul><li>建立一个信息安全通道，来保证数据传输的安全</li> <li>确认网站的真实性，防止钓鱼网站</li></ul> <h3 id="https的原理"><a href="#https的原理" class="header-anchor">#</a> <code>HTTPS</code>的原理</h3> <p>由于<code>HTTPS</code>的原理不是很容易看懂，我们用一个简单的实例来进行说明：来自中国的 <strong>张大胖</strong> 和位于米国的 <strong>Bill</strong> 想要进行安全的通信。</p> <p>由于张大胖和 Bill 都是使用 <code>HTTP</code> 进行通信，<code>HTTP</code> 是明文的，所以他们的聊天都是可被窥视的。于是，二人准备想要改变现状，所以 <code>HTTPS</code> 首先要解决的问题就是要保证传输的内容只有这两个人能看懂</p> <h4 id="对称加密"><a href="#对称加密" class="header-anchor">#</a> 对称加密</h4> <p><img src="/plan1.jpg" alt="plan1"></p> <p>两人商量了一下，可以使用对称密钥进行加密。（对称密钥：加密和解密使用的是同一个密钥）。</p> <p><strong>对称加密的问题</strong>：既然网络是不安全的，那么最开始的时候怎么将这个对称密钥发送出去呢？如果对称密钥在发送的时候就已经被拦截，那么发送的信息还是会被篡改和窥视。</p> <p>所以这种对称密钥的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息就行窥视和篡改。</p> <h4 id="非对称加密"><a href="#非对称加密" class="header-anchor">#</a> 非对称加密</h4> <p>非对称加密算法（<code>RSA</code>）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p> <p><img src="/plan2.png" alt="plan2"></p> <p>Bill 将自己的公钥给张大胖，张大胖发送的信息使用 Bill 的公钥加密，这样，只有 Bill 使用自己的私钥才能获取。</p> <p><strong>非对称加密的弊端</strong>：虽然非对称加密解决了安全的问题，但是非对称加密算法很慢，比对称加密算法慢很多。</p> <p>所以为了解决这个问题，我们可以使用<code>非对称密钥</code>+<code>对称密钥</code>结合的方式。</p> <h4 id="对称加密-非对称加密"><a href="#对称加密-非对称加密" class="header-anchor">#</a> 对称加密 + 非对称加密</h4> <p>对称加密的优点是速度比较快，非对称加密的优点是传输的内容不能被破解。所以结合两者的优点，使用非对称加密的方法将对称加密的密钥发送过去，之后就可以使用使用这个密钥，利用对称密钥来通信了。就比如说我将钥匙放进了保险柜，然后将保险柜寄给对方。</p> <h4 id="公钥的传输"><a href="#公钥的传输" class="header-anchor">#</a> 公钥的传输</h4> <p><strong>中间人攻击</strong>：还有一个问题就是在使用非对称密钥的时候，首先需要将 Bill 的公钥给张大胖，那么在这个过程中，安全是没有保障的，中间人可以拦截到 Bill 的公钥，就可以对拦截到的公钥进行篡改。</p> <p>但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。</p> <p>在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！</p> <p>证书怎么安全传输？</p> <p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。</p> <p><img src="/ssl1.png" alt="ssl1"></p> <p>可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”</p> <p><strong>数字签名</strong> 张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称<code>CA</code>）用它的私钥对消息摘要加密，形成签名：</p> <p><img src="/ssl2.png" alt="ssl2"></p> <p><strong>数字证书</strong> 这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书”：</p> <p><img src="/ssl3.png" alt="ssl3"></p> <p>张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p> <p><img src="/ssl4.png" alt="ssl4"></p> <p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。</p> <blockquote><p>这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。</p></blockquote> <h4 id="https流程图"><a href="#https流程图" class="header-anchor">#</a> HTTPS流程图</h4> <p>一个简化的HTTPS流程图是这样的：</p> <p><img src="/https.png" alt="https"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后修改时间:</span> <span class="time">9/2/2020, 3:07:48 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.be40bd60.js" defer></script><script src="/assets/js/2.fcfb7384.js" defer></script><script src="/assets/js/9.89661334.js" defer></script>
  </body>
</html>
